//===- Ddot.cpp -----------------------------------------------------------===//
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//===----------------------------------------------------------------------===//
//
// This file provides the linpackc ddot function.
//
//===----------------------------------------------------------------------===//
#include <math.h>
#include <stdio.h>

void dmxpy_TYPE_PLACEHOLDER_COMPILER_PLACEHOLDER(int n1, TYPE_PLACEHOLDER y[],
                                                 int n2, int ldm,
                                                 TYPE_PLACEHOLDER x[],
                                                 TYPE_PLACEHOLDER m[])

/* We would like to declare m[][ldm], but c does not allow it.  In this
function, references to m[i][j] are written m[ldm*i+j].  */

/*
   purpose:
     multiply matrix m times vector x and add the result to vector y.

   parameters:

     n1 integer, number of elements in vector y, and number of rows in
         matrix m

     y double [n1], vector of length n1 to which is added
         the product m*x

     n2 integer, number of elements in vector x, and number of columns
         in matrix m

     ldm integer, leading dimension of array m

     x double [n2], vector of length n2

     m double [ldm][n2], matrix of n1 rows and n2 columns

 ----------------------------------------------------------------------
*/
{
  int j, i, jmin;
  /* cleanup odd vector */

  j = n2 % 2;
  if (j >= 1) {
    j = j - 1;
    for (i = 0; i < n1; i++)
      y[i] = (y[i]) + x[j] * m[ldm * j + i];
  }

  /* cleanup odd group of two vectors */

  j = n2 % 4;
  if (j >= 2) {
    j = j - 1;
    for (i = 0; i < n1; i++)
      y[i] = ((y[i]) + x[j - 1] * m[ldm * (j - 1) + i]) + x[j] * m[ldm * j + i];
  }

  /* cleanup odd group of four vectors */

  j = n2 % 8;
  if (j >= 4) {
    j = j - 1;
    for (i = 0; i < n1; i++)
      y[i] = ((((y[i]) + x[j - 3] * m[ldm * (j - 3) + i]) +
               x[j - 2] * m[ldm * (j - 2) + i]) +
              x[j - 1] * m[ldm * (j - 1) + i]) +
             x[j] * m[ldm * j + i];
  }

  /* cleanup odd group of eight vectors */

  j = n2 % 16;
  if (j >= 8) {
    j = j - 1;
    for (i = 0; i < n1; i++)
      y[i] = ((((((((y[i]) + x[j - 7] * m[ldm * (j - 7) + i]) +
                   x[j - 6] * m[ldm * (j - 6) + i]) +
                  x[j - 5] * m[ldm * (j - 5) + i]) +
                 x[j - 4] * m[ldm * (j - 4) + i]) +
                x[j - 3] * m[ldm * (j - 3) + i]) +
               x[j - 2] * m[ldm * (j - 2) + i]) +
              x[j - 1] * m[ldm * (j - 1) + i]) +
             x[j] * m[ldm * j + i];
  }

  /* main loop - groups of sixteen vectors */

  jmin = (n2 % 16) + 16;
  for (j = jmin - 1; j < n2; j = j + 16) {
    for (i = 0; i < n1; i++)
      y[i] = ((((((((((((((((y[i]) + x[j - 15] * m[ldm * (j - 15) + i]) +
                           x[j - 14] * m[ldm * (j - 14) + i]) +
                          x[j - 13] * m[ldm * (j - 13) + i]) +
                         x[j - 12] * m[ldm * (j - 12) + i]) +
                        x[j - 11] * m[ldm * (j - 11) + i]) +
                       x[j - 10] * m[ldm * (j - 10) + i]) +
                      x[j - 9] * m[ldm * (j - 9) + i]) +
                     x[j - 8] * m[ldm * (j - 8) + i]) +
                    x[j - 7] * m[ldm * (j - 7) + i]) +
                   x[j - 6] * m[ldm * (j - 6) + i]) +
                  x[j - 5] * m[ldm * (j - 5) + i]) +
                 x[j - 4] * m[ldm * (j - 4) + i]) +
                x[j - 3] * m[ldm * (j - 3) + i]) +
               x[j - 2] * m[ldm * (j - 2) + i]) +
              x[j - 1] * m[ldm * (j - 1) + i]) +
             x[j] * m[ldm * j + i];
  }
}
